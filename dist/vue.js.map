{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/utils.js","../src/state.js","../src/index.js","../src/init.js"],"sourcesContent":["// import { observe } from \"index.js\";\r\n\r\nconst oldArrayProto = Array.prototype; // 获取数组的老的原型方法\r\n\r\nconst arrayMethods = Object.create(oldArrayProto); // 让arrayMethods通过__proto__ 能获取数组方法\r\n\r\n// 只有这七个方法 可以导致数组发生变化\r\nconst methods = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'reverse',\r\n    'splice'\r\n];\r\n\r\nmethods.forEach(method => {\r\n    arrayMethods[method] = function () {\r\n        console.log('观测了数组')\r\n    }\r\n});\r\n\r\nexport default arrayMethods;\r\n","import { isArray, isObject } from \"../utils\";\r\nimport arrayMethods from \"./array\";\r\n\r\nclass Observe {\r\n    constructor(value) {\r\n        if (isArray(value)) {\r\n            value.__proto__ = arrayMethods;\r\n        } else {\r\n            this.walk(value);//核心就是循环对象\r\n        }\r\n    }\r\n\r\n    walk(data) {\r\n        Object.keys(data).forEach(key => {\r\n            // 要使用defineProperty重新定义\r\n            defineProperty(data, key, data[key]);\r\n        });\r\n    }\r\n}\r\n\r\n// vue2 应用了defineProperty需要 加载的时候 就进行递归操作 所以耗性能 如果层次过深会浪费性能\r\n// 1).性能优化原则\r\n// 2).不要写数据的时候 层级过深 尽量扁平化数据\r\n// 3).不要频繁获取数据\r\n// 4).如果数据不需要响应式 可以使用Object.freeze 冻结属性\r\nfunction defineProperty(obj, key, value) {\r\n    // 递归进行观测数据 不管有多少层 都进行defineProperty\r\n    observe(value);\r\n    Object.defineProperty(obj, key, {\r\n        get() {\r\n            // 闭包 此value 会像上一层的value进行查找\r\n            return value;\r\n        },\r\n        set(newValue) {\r\n            if (value === newValue) return;\r\n            observe(newValue);\r\n            value = newValue;\r\n        }\r\n    })\r\n}\r\n\r\nexport function observe(value) {\r\n\r\n    // 1.如果value不是对象，就不用观测了\r\n    if (!isObject(value)) return;\r\n    // 需要对对象进行观测(最外层必须是一个{} 不能是数组)\r\n\r\n    // 如果一个数据已经备观测过就不必再观测 用类来实现 观察过就增加一个标识 说明观测过了 在观测的时候 可以\r\n    // 先检测是否观测过 如果观测过就跳过检测\r\n\r\n    return new Observe(value);\r\n}","//判断是否是函数\r\nexport function isFunction(val) {\r\n    return typeof val === 'function';\r\n}\r\n\r\n//判断是否是对象\r\nexport function isObject(val) {\r\n    return typeof val === 'object' && val !== null;\r\n}\r\n\r\n//判断是否是数组\r\nexport function isArray(val) {\r\n    return Array.isArray(val);\r\n}","import {\r\n    observe\r\n} from \"./observe/index\";\r\nimport {\r\n    isFunction\r\n} from \"./utils\";\r\n\r\nexport function initState(vm) {\r\n    const ops = vm.$options;\r\n    if (ops.data) {\r\n        initData(vm);\r\n    }\r\n}\r\n\r\nfunction proxy(obj, key, source) {\r\n    // 取值的时候做代理 不是暴力把_data属性赋予给vm 而且直接赋值会命名冲突问题\r\n    Object.defineProperty(obj, key, {\r\n        get() {\r\n            return obj[source][key];\r\n        },\r\n        set(newValue) {\r\n            obj[source][key] = newValue;\r\n        }\r\n    })\r\n}\r\n\r\nfunction initData(vm) {\r\n    //用户传入数据\r\n    let data = vm.$options.data;\r\n\r\n    // 如果用户传递的是一个函数 则取函数的返回值作为对象，对象则是对象\r\n    // 只有根实例data可以是一个对象\r\n\r\n    // data和vm._data 是同一个对象 引用的是同一个人 -> data被劫持了 vm._data也被劫持\r\n    data = vm._data = isFunction(data) ? data.call(vm) : data; //_data已经是响应式了\r\n\r\n    // 初始化数据\r\n    // 需要将data变成响应式Objetct.defineProperty 重写data中的数据\r\n    observe(data);\r\n    for (const key in data) {\r\n        proxy(vm, key, '_data')\r\n    }\r\n}","import { initMixin } from './init';\r\n\r\n//vue 要如何实现 原型模式 所有的功能都通过原型扩展的方式来添加 \r\nfunction Vue(options) {\r\n    this._init(options); //实现初始化vue\r\n}\r\n\r\n// 初始化\r\ninitMixin(Vue);\r\n\r\n// 导出vue给别人使用\r\nexport default Vue;\r\n\r\n// 1.new Vue 会调用_init方法进行初始化操作\r\n// 2.会将用户的选项放在vm.$options上\r\n// 3.会对当前属性上搜索有没有data数据 initState\r\n// 4.有data判断data是不是一个函数 如果是函数取返回值 initData\r\n// 5.observe取观测data中的数据\r\n// 6.vm上取值也能取到data中的数据 vm._data = data 这样用户能取到data了 vm._data\r\n// 7.用户觉得有点麻烦vm.xxx =>vm._data\r\n\r\n// 如果el需要挂载在页面上","import { initState } from \"./state\";\r\n\r\nexport function initMixin(Vue) {\r\n    // 后续组件化开发的时候 Vue.extend 可以创造一个子组件 子组件可以继承Vue,子组件也可以调用_init方法\r\n    Vue.prototype._init = function(options) {\r\n        const vm = this;\r\n\r\n        //把用户的选项放在 vm上,这样在其他方法中都可以获取到options\r\n        vm.$options = options; //为了后续扩展的方法 都可以获取到$optios\r\n\r\n        // options 中用户传入数据el ，data\r\n        initState(vm);\r\n        if (vm.$options.el) {\r\n            // 要降数据挂载到页面上\r\n            console.log('页面要挂载')\r\n        }\r\n    }\r\n}"],"names":["oldArrayProto","Array","prototype","arrayMethods","Object","create","forEach","method","console","log","Observe","constructor","value","isArray","__proto__","walk","data","keys","key","obj","observe","defineProperty","get","set","newValue","val","initState","vm","$options","_data","call","source","proxy","initData","Vue","options","_init","this","el"],"mappings":"wfAEA,IAAMA,EAAgBC,MAAMC,UAE5B,MAAMC,EAAeC,OAAOC,OAAOL,GAGnB,CACZ,OACA,MACA,QACA,UACA,SACA,UACA,UAGIM,QAAQC,IACZJ,EAAaI,GAAU,WACnBC,QAAQC,IAAI,kBChBdC,EACFC,YAAYC,GCQLX,MAAMY,QDPGD,GACRA,EAAME,UAAYX,OAEbY,KAAKH,GAIlBG,KAAKC,GACDZ,OAAOa,KAAKD,GAAMV,QAAQY,IAYlC,IAAwBC,EAAUP,EAE9BQ,EAF8BR,GAAVO,EAVGH,GAUEE,EAVIA,IAa7Bd,OAAOiB,eAAeF,EAAKD,EAAK,CAC5BI,aAEWV,GAEXW,IAAIC,GACIZ,IAAUY,IACdJ,EAAQI,GACRZ,EAAQY,SAKb,SAASJ,EAAQR,GCnCjB,IAAkBa,QACC,iBADDA,EDsCPb,ICrC4B,OAARa,GD2C3B,IAAIf,EAAQE,GE3ChB,SAASc,EAAUC,GACVA,EAAGC,SACPZ,MAiBZ,SAAkBW,OAEVX,EAAOW,EAAGC,SAASZ,KAMvBA,EAAOW,EAAGE,MDhCY,mBCgCOb,EAAQA,EAAKc,KAAKH,GAAMX,EAIrDI,EAAQJ,OACH,MAAME,KAAOF,GAzBtB,SAAeG,EAAKD,EAAKa,GAErB3B,OAAOiB,eAAeF,EAAKD,EAAK,CAC5BI,aACWH,EAAIY,GAAQb,IAEvBK,IAAIC,GACAL,EAAIY,GAAQb,GAAOM,KAmBvBQ,CAAML,EAAIT,EAAK,SA9Bfe,CAASN,GCPjB,SAASO,EAAIC,QACJC,MAAMD,UAILD,ECJFhC,UAAUkC,MAAQ,SAASD,OACrBR,EAAKU,KAGXV,EAAGC,SAAWO,EAGdT,EAAUC,GACNA,EAAGC,SAASU,IAEZ9B,QAAQC,IAAI"}